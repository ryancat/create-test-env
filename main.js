#! /usr/bin/env node

// Imports
const fs = require('fs')
const path = require('path')
const shell = require('shelljs')
const program = require('commander')
const deepEqual = require('deep-equal')

const util = require('./util')

// Reading from src files
const packageJson = require('./package.json')

// parsing process arguments
program
  .version(packageJson.version, '-v, --version')
  .option('-u, --unit-test-pattern', 'The unit test specs file pattern', 'tests/unit/**/*.test.js')
  .option('-f, --functional-test-pattern', 'The functional test specs file pattern', 'tests/functional/**/*.test.js')
  .option('-c, --conf-path', 'Test config file', 'test.conf.js')
  // .option('-P, --pineapple', 'Add pineapple')
  // .option('-b, --bbq-sauce', 'Add bbq sauce')
  // .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')
  .parse(process.argv);
class TaskRunner {

  constructor (props = {}) {
    this.log = shell.test('-f', TaskRunner.TASK_LOG_PATH) 
      ? JSON.parse(fs.readFileSync(TaskRunner.TASK_LOG_PATH))
      : {}

    // The process argument processor
    this.program = props.program
    // The test configuration JSON
    this.testConf = {}
    this.testConfPath = TaskRunner.DEFAULT_CONF_PATH
  }

  static get TEMPLATE_CONF_PATH () {
    return path.resolve(__dirname, 'test.template.conf.js')
  }

  static get DEFAULT_CONF_PATH () {
    return TaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEST_CONF_PATH () {
    return TaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEMPLATES_PATH () {
    return path.resolve(__dirname, 'templates/')
  }

  static get TASK_LOG_PATH () {
    return TaskRunner._getTargetPath('.create_test_env.log')
  }

  static _getTargetPath (relativePath) {
    return path.resolve(process.cwd(), relativePath)
  }

  static _getTemplatePath (filename) {
    return path.resolve(TaskRunner.TEMPLATES_PATH, filename)
  }

  _isDefaultConf (confKey) {
    return deepEqual(this.testConf[confKey], require(TaskRunner.TEMPLATE_CONF_PATH)[confKey])
  }

  _addToAutoGenerated (autoGenPath) {
    this.log.autoGenerated = this.log.autoGenerated || []
    this.log.autoGenerated.push(autoGenPath)
  }

  // Create file structure
  // Create test.conf.js
  createTestConf () {
    // Read from argument
    if (this.program.confPath) {
      // Overwrite default one
      this.testConfPath = this.program.confPath
    }

    if (!shell.test('-f', this.testConfPath)) {
      // If the test configure file not exist, we need to create one from default
      console.log(`Create test config file at ${this.testConfPath}`)

      fs.writeFileSync(
        this.testConfPath, 
        fs.readFileSync(TaskRunner.TEMPLATE_CONF_PATH))

      this._addToAutoGenerated(this.testConfPath)
      this.testConf = require(this.testConfPath)
    }
    else {
      // config file exists. Need to add defaults
      this.testConf = util.getExtendDefault(
        require(this.testConfPath), 
        require(TaskRunner.TEMPLATE_CONF_PATH)
      )
    }

    return this
  }

  // Create test directory (if using default)
  createUnitTests () {
    if (!this._isDefaultConf('unit_specs')) {
      // The unit test specs are using non-default pattern
      // consumer should provide their own test specs here
      return this
    }

    const unitTestDir = TaskRunner._getTargetPath(this.testConf._unit_test_dir)

    if (shell.test('-e', unitTestDir)) {
      // If the unit test directory already exists, do nothing.
      // We will rely on the unit test file pattern option to decide
      // which file to run unit test
      return this
    }

    shell.mkdir('-p', unitTestDir);

    this._addToAutoGenerated(unitTestDir)

    const exampleUnitTestPath = path.resolve(unitTestDir, 'example.test.js')
    fs.writeFileSync(exampleUnitTestPath, fs.readFileSync(TaskRunner._getTemplatePath('unit.test.js')))
    this._addToAutoGenerated(exampleUnitTestPath)

    return this
  }

  /**
   * Clean the directories/files created
   */
  clean () {
    if (!this.log.autoGenerated) {
      // Nothing to clean
      return this
    }

    this.log.autoGenerated.forEach(autoGenPath => shell.rm('-rf', autoGenPath))
    
    return this
  }

  /**
   * Final tasks
   */
  final () {
    // Create task log
    // Write auto generated logs
    fs.writeFileSync(TaskRunner.TASK_LOG_PATH, JSON.stringify(this.log))
  }
}






// Clean file structure

// Read templates
// createUnitTests()


// Main workflow
let taskRunner = new TaskRunner({
  program: program
})

taskRunner
  .clean()
  .createTestConf()
  .createUnitTests()
  .final()