// Nodejs imports
const fs = require('fs')
const path = require('path')
const { exec, spawn } = require('child_process');

// Thrid party
const shell = require('shelljs')
// TODO: make my simple-deep-equal as good as deep-equal
const deepEqual = require('simple-deep-equal').deepEqual
const inquirer = require('inquirer')

// Source imports
const util = require('./util')
const PipeRunner = require('./PipeRunner')

class AsyncTaskRunner {

  constructor (props = {}) {
    // For async workflow
    const pipeRunner = new PipeRunner(this)
    this.pipe = (taskFn) => {
      if (typeof taskFn === 'string') {
        taskFn = this[taskFn]
      }

      pipeRunner.pipe(taskFn.bind(this))
      return this
    }

    this.log = shell.test('-f', AsyncTaskRunner.TASK_LOG_PATH) 
      ? JSON.parse(fs.readFileSync(AsyncTaskRunner.TASK_LOG_PATH))
      : {}

    // The process argument processor
    this.options = props.options
    // The test configuration JSON
    this.testConf = {}
    this.testConfPath = AsyncTaskRunner.DEFAULT_CONF_PATH
  }

  // static get TEMPLATE_CONF_PATH () {
  //   return path.resolve(__dirname, 'test.template.conf.js')
  // }

  static get TEMPLATE_WDIO_CONF_PATH () {
    return path.resolve(__dirname, 'wdio.template.conf.js')
  }

  static get DEFAULT_CONF_PATH () {
    return AsyncTaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEST_CONF_PATH () {
    return AsyncTaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEMPLATES_PATH () {
    return path.resolve(__dirname, 'templates/')
  }

  static get TASK_LOG_PATH () {
    return AsyncTaskRunner._getTargetPath('.create_test_env.log')
  }

  static _getTargetPath (relativePath) {
    return path.resolve(process.cwd(), relativePath)
  }

  static _getTemplatePath (filename) {
    return path.resolve(AsyncTaskRunner.TEMPLATES_PATH, filename)
  }

  /**
   * Clean generated file based on .create_test_env.log
   */
  static clean () {
    const log = shell.test('-f', AsyncTaskRunner.TASK_LOG_PATH) 
      ? JSON.parse(fs.readFileSync(AsyncTaskRunner.TASK_LOG_PATH))
      : {}
    
    if (!log.autoGenerated) {
      // Nothing to clean
      return
    }

    log.autoGenerated.forEach(autoGenPath => {
      shell.rm('-rf', autoGenPath)
    })
    log.autoGenerated = []
    fs.writeFileSync(AsyncTaskRunner.TASK_LOG_PATH, JSON.stringify(log))
  }

  // _isDefaultConf (confKey) {
  //   return deepEqual(this.testConf[confKey], require(AsyncTaskRunner.TEMPLATE_CONF_PATH)[confKey])
  // }

  _addToAutoGenerated (autoGenPath) {
    this.log.autoGenerated = this.log.autoGenerated || []
    if (this.log.autoGenerated.indexOf(autoGenPath) === -1) {
      // Add to autogenerated file list if haven't
      this.log.autoGenerated.push(autoGenPath)
    }
  }

  // Create file structure
  // Create test.conf.js
  // async createTestConf () {
  //   // Read from argument
  //   if (this.options.confPath) {
  //     // Overwrite default one
  //     this.testConfPath = this.options.confPath
  //   }

  //   if (!shell.test('-f', this.testConfPath)) {
  //     // If the test configure file not exist, we need to create one from default
  //     console.log(`Create test config file at ${this.testConfPath}`)

  //     fs.writeFileSync(
  //       this.testConfPath, 
  //       fs.readFileSync(AsyncTaskRunner.TEMPLATE_CONF_PATH))

  //     this._addToAutoGenerated(this.testConfPath)
  //     this.testConf = require(this.testConfPath)
  //   }
  //   else {
  //     // config file exists. Need to add defaults
  //     this.testConf = util.getExtendDefault(
  //       require(this.testConfPath), 
  //       require(AsyncTaskRunner.TEMPLATE_CONF_PATH)
  //     )
  //   }

  //   return this
  // }

  async createUnitTestSpecs () {
    await this._createTestsSpecs('unit')
    return this
  }

  async createFunctionalTestSpecs () {
    await this._createTestsSpecs('functional')
    return this
  }

  // Create test directory (if using default)
  async _createTestsSpecs (testType = 'unit') {
    let defaultSpecPath,
        specPath,
        templateFile

    switch (testType) {
      case 'unit': 
        defaultSpecPath = './example.unit.test.js'
        specPath = await inquirer.prompt({
          type: 'input', 
          name: 'unitTestExamplePath',
          message: 'Where the unit test spec example should be?',
          default: defaultSpecPath
        })
        templateFile = 'unit.test.js'
        break

      case 'functional': 
        defaultSpecPath = './example.functional.test.js'
        specPath = await inquirer.prompt({
          type: 'input', 
          name: 'functionalTestExamplePath',
          message: 'Where the functional test spec example should be?',
          default: defaultSpecPath
        })
        templateFile = 'functional.test.js'
        break
      
      default:
        console.log('Try to create invalid test specs.')
        process.exit(1);
    }

    // if (!this._isDefaultConf(specConf)) {
    //   // The unit test specs are using non-default pattern
    //   // consumer should provide their own test specs here
    //   return this
    // }

    let targetSpecPath = AsyncTaskRunner._getTargetPath(specPath)

    // Check if the file already exists, and confirm overwrite
    while (shell.test('-e', targetSpecPath)) {
      targetSpecPath = (await inquirer.prompt({
        type: 'input', 
        name: 'testExamplePath',
        message: 'The given path exists. Try a different one?'
      })).testExamplePath
    }
    // const exampleUnitTestPath = path.resolve(targetSpecPath, 'example.test.js')
    fs.writeFileSync(targetSpecPath, fs.readFileSync(AsyncTaskRunner._getTemplatePath(templateFile)))
    this._addToAutoGenerated(targetSpecPath)

    return this
  }

  async _addTestConfigInPackageJson (testConfig) {
    const packageJsonPath = AsyncTaskRunner._getTargetPath('./package.json')
    let packageJson,
        i

    if (!shell.test('-f', packageJsonPath)) {
      // No package.json found. Need to create one for npm
      packageJson = {
        scripts: {},
        devDependencies: {}
      }
    }
    else {
      packageJson = JSON.parse(fs.readFileSync(packageJsonPath))
    }

    for (i = 0; i < testConfig.testScripts.length; i++) {
      let testScript = testConfig.testScripts[i]
      let answer = testScript

      while(packageJson.scripts[answer.testScriptKey]) {
        answer = await inquirer.prompt({
          type: 'input', 
          name: 'testScriptKey',
          message: `"${answer.testScriptKey}" already exists. Try a different one?`,
          default: `${answer.testScriptKey}_`
        })
      }
      packageJson.scripts[answer.testScriptKey] = testScript.testScriptValue
    }

    // testConfig.testScripts.forEach((testScript) => {
    //   let answer = testScript

    //   while(packageJson.scripts[answer.testScriptKey]) {
    //     answer = await inquirer.prompt({
    //       type: 'input', 
    //       name: 'testScriptKey',
    //       message: `"${answer.testScriptKey}" already exists. Try a different one?`,
    //       default: `${answer.testScriptKey}-v2`
    //     })
    //   }
    //   packageJson.scripts[answer.testScriptKey] = testScript.testScriptValue
    // })

    for (i = 0; i < testConfig.devDependencies.length; i++) {
      let devDependency = testConfig.devDependencies[i]
      let answer = devDependency
      if (packageJson.devDependencies[devDependency.devDependencyKey]) {
        console.log(`"${answer.devDependencyKey}" already exists. Leave it unchanged.`)
      }
      else {
        packageJson.devDependencies[devDependency.devDependencyKey] = devDependency.devDependencyValue
      }
    }

    // testConfig.devDependencies.forEach((devDependency) => {
    //   let answer = devDependency
    //   if (packageJson.devDependencies[devDependency.devDependencyKey]) {
    //     console.log(`"${answer.devDependencyKey}" already exists. Leave it unchanged.`)
    //   }
    //   else {
    //     packageJson.devDependencies[devDependency.devDependencyKey] = devDependency.devDependencyValue
    //   }
    // })

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2))
    return this
  }

  /**
   * Add npm dependencies and scripts into project for unit tests
   */
  async addUnitTestConfigInPackageJson () {
    const unitTestSpecPatternAnswer = await inquirer.prompt({
      type: 'input', 
      name: 'unitTestSpecPattern',
      message: 'What\'s the unit test spec pattern?',
      default: './src/**/*.unit.test.js'
    })

    const unitTestScriptKeyAnswer = await inquirer.prompt({
      type: 'input', 
      name: 'unitTestScriptKey',
      message: 'What\'s the name of your unit test npm script?',
      default: 'test:unit'
    })

    const testConfig = {
      testScripts: [{
        testScriptKey: unitTestScriptKeyAnswer.unitTestScriptKey,
        testScriptValue: `mocha ${unitTestSpecPatternAnswer.unitTestSpecPattern}`
      }],
      devDependencies: [{
        devDependencyKey: 'mocha',
        devDependencyValue: 'latest'
      }]
    }

    await this._addTestConfigInPackageJson(testConfig)
    return this
  }

  async addFunctionalTestConfigInPackageJson () {
    
    const functionalTestScriptKeyAnswer = await inquirer.prompt({
      type: 'input', 
      name: 'functionalTestScriptKey',
      message: 'What\'s the name of your functional test npm script?',
      default: 'test:functional'
    })

    const testConfig = {
      testScripts: [{
        testScriptKey: functionalTestScriptKeyAnswer.functionalTestScriptKey,
        testScriptValue: `wdio wdio.config.js`
      }],
      devDependencies: [{
        devDependencyKey: 'webdriverio',
        devDependencyValue: 'latest'
      }]
    }

    await this._addTestConfigInPackageJson(testConfig)
    return this
  }

  // Add functional test config (wdio.config.js)
  // Just using wdio config helper wizard
  async addFunctionalTestConfig () {
    if (!this.hasNpmInstalled) {
      await this.npmInstall()
    }

    // Now using webdriverio config wizard
    try {
      const wdioConfigResult = await new Promise((resolve, reject) => {
        // exec(`cd ${AsyncTaskRunner._getTargetPath('./')} && ./node_modules/.bin/wdio config`)
        // .on('close', (code) => {
        //   code === 0 ? resolve(code) : reject(code)
        // })

        let run = spawn('./node_modules/.bin/wdio', ['config'])

        run.stdout.on('data', (data) => console.log(data.toString()))
        run.stderr.on('data', (data) => console.log(data.toString()))
        run.on('exit', (code) => {
          code === 0 ? resolve() : reject(code)
        })
      })
    }
    catch (err) {
      console.log(err);
      process.exit(1);
    }

    this._addToAutoGenerated(AsyncTaskRunner._getTargetPath('./wdio.config.js'))
    return this
  }

  // Install the updated package.json
  async npmInstall () {
    console.log('Install npm packages...')
    // await new Promise((resolve, reject) => {
    //   exec(`cd ${AsyncTaskRunner._getTargetPath('./')} && npm install`)
    //   .on('close', (code) => {
    //     code === 0 ? resolve() : reject()
    //   })
    // })
    try {
      // await new Promise((resolve, reject) => {
      //   exec(`cd ${AsyncTaskRunner._getTargetPath('./')} && npm install`)
      //   .on('close', (code) => {
      //     code === 0 ? resolve(code) : reject(code)
      //   })
      // })

      await new Promise((resolve, reject) => {
        let run = spawn('npm', ['install'])

        run.stdout.on('data', (data) => console.log(data.toString()))
        run.stderr.on('data', (data) => console.log(data.toString()))
        run.on('exit', (code) => {
          code === 0 ? resolve() : reject(code)
        })
      })
    }
    catch (err) {
      console.log(err);
      process.exit(1);
    }

    return this
  }

  /**
   * Clean the directories/files created
   */
  async clean () {
    if (!this.log.autoGenerated) {
      // Nothing to clean
      return this
    }

    this.log.autoGenerated.forEach(autoGenPath => shell.rm('-rf', autoGenPath))
    this.log.autoGenerated = []

    return this
  }

  /**
   * Final tasks
   */
  async final () {
    // Create task log
    // Write auto generated logs
    fs.writeFileSync(AsyncTaskRunner.TASK_LOG_PATH, JSON.stringify(this.log))
  }
}

module.exports = AsyncTaskRunner