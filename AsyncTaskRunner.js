// Nodejs imports
const fs = require('fs')
const path = require('path')
const { exec } = require('child_process');

// Thrid party
const shell = require('shelljs')
// TODO: make my simple-deep-equal as good as deep-equal
const deepEqual = require('simple-deep-equal').deepEqual
const inquirer = require('inquirer')

// Source imports
const util = require('./util')
const PipeRunner = require('./PipeRunner')

class AsyncTaskRunner {

  constructor (props = {}) {
    // For async workflow
    const pipeRunner = new PipeRunner(this)
    this.pipe = (taskFn) => {
      if (typeof taskFn === 'string') {
        taskFn = this[taskFn]
      }

      pipeRunner.pipe(taskFn.bind(this))
      return this
    }

    this.log = shell.test('-f', AsyncTaskRunner.TASK_LOG_PATH) 
      ? JSON.parse(fs.readFileSync(AsyncTaskRunner.TASK_LOG_PATH))
      : {}

    // The process argument processor
    this.options = props.options
    // The test configuration JSON
    this.testConf = {}
    this.testConfPath = AsyncTaskRunner.DEFAULT_CONF_PATH
  }

  static get TEMPLATE_CONF_PATH () {
    return path.resolve(__dirname, 'test.template.conf.js')
  }

  static get DEFAULT_CONF_PATH () {
    return AsyncTaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEST_CONF_PATH () {
    return AsyncTaskRunner._getTargetPath('./test.conf.js')
  }

  static get TEMPLATES_PATH () {
    return path.resolve(__dirname, 'templates/')
  }

  static get TASK_LOG_PATH () {
    return AsyncTaskRunner._getTargetPath('.create_test_env.log')
  }

  static _getTargetPath (relativePath) {
    return path.resolve(process.cwd(), relativePath)
  }

  static _getTemplatePath (filename) {
    return path.resolve(AsyncTaskRunner.TEMPLATES_PATH, filename)
  }

  /**
   * Clean generated file based on .create_test_env.log
   */
  static clean () {
    const log = shell.test('-f', AsyncTaskRunner.TASK_LOG_PATH) 
      ? JSON.parse(fs.readFileSync(AsyncTaskRunner.TASK_LOG_PATH))
      : {}
    
    if (!log.autoGenerated) {
      // Nothing to clean
      return
    }

    log.autoGenerated.forEach(autoGenPath => {
      shell.rm('-rf', autoGenPath)
    })
    log.autoGenerated = []
    fs.writeFileSync(AsyncTaskRunner.TASK_LOG_PATH, JSON.stringify(log))
  }

  _isDefaultConf (confKey) {
    return deepEqual(this.testConf[confKey], require(AsyncTaskRunner.TEMPLATE_CONF_PATH)[confKey])
  }

  _addToAutoGenerated (autoGenPath) {
    this.log.autoGenerated = this.log.autoGenerated || []
    if (this.log.autoGenerated.indexOf(autoGenPath) === -1) {
      // Add to autogenerated file list if haven't
      this.log.autoGenerated.push(autoGenPath)
    }
  }

  // Create file structure
  // Create test.conf.js
  async createTestConf () {
    // Read from argument
    if (this.options.confPath) {
      // Overwrite default one
      this.testConfPath = this.options.confPath
    }

    if (!shell.test('-f', this.testConfPath)) {
      // If the test configure file not exist, we need to create one from default
      console.log(`Create test config file at ${this.testConfPath}`)

      fs.writeFileSync(
        this.testConfPath, 
        fs.readFileSync(AsyncTaskRunner.TEMPLATE_CONF_PATH))

      this._addToAutoGenerated(this.testConfPath)
      this.testConf = require(this.testConfPath)
    }
    else {
      // config file exists. Need to add defaults
      this.testConf = util.getExtendDefault(
        require(this.testConfPath), 
        require(AsyncTaskRunner.TEMPLATE_CONF_PATH)
      )
    }

    return this
  }

  async createUnitTestSpecs () {
    await this._createTestsSpecs('unit')
    return this
  }

  async createFunctionalTestSpecs () {
    await this._createTestsSpecs('functional')
    return this
  }

  // Create test directory (if using default)
  async _createTestsSpecs (testType = 'unit') {
    let specDir,
        specConf,
        templateFile

    switch (testType) {
      case 'unit': 
        specDir = this.testConf._unit_test_dir
        specConf = 'unit_specs'
        templateFile = 'unit.test.js'
        break

      case 'functional': 
        specDir = this.testConf._functional_test_dir
        specConf = 'functional_specs'
        templateFile = 'functional.test.js'
        break
      
      default:
        specDir = this.testConf._unit_test_dir
        specConf = 'unit_specs'
        templateFile = 'unit.test.js'
        break
    }

    if (!this._isDefaultConf(specConf)) {
      // The unit test specs are using non-default pattern
      // consumer should provide their own test specs here
      return this
    }

    const targetTestDir = AsyncTaskRunner._getTargetPath(specDir)

    if (shell.test('-e', targetTestDir)) {
      // If the unit test directory already exists, do nothing.
      // We will rely on the unit test file pattern option to decide
      // which file to run unit test
      return this
    }

    shell.mkdir('-p', targetTestDir);

    this._addToAutoGenerated(targetTestDir)

    const exampleUnitTestPath = path.resolve(targetTestDir, 'example.test.js')
    fs.writeFileSync(exampleUnitTestPath, fs.readFileSync(AsyncTaskRunner._getTemplatePath(templateFile)))
    this._addToAutoGenerated(exampleUnitTestPath)

    return this
  }

  /**
   * Add npm dependencies and scripts into project for unit tests
   */
  async addUnitTestScripts () {
    const packageJsonPath = AsyncTaskRunner._getTargetPath('./package.json')
    let packageJsonDirty = false,
        mochaTestScript = `mocha ${this.testConf.unit_specs.join(' ')}`,
        packageJson

    let answer = await inquirer.prompt({
      type: 'input', 
      name: 'unitTestScriptKey',
      message: 'What\'s the name of your unit test npm script?',
      default: 'test:unit'
    })

    if (!shell.test('-f', packageJsonPath)) {
      // No package.json found. Need to create one for npm
      packageJson = {
        scripts: {},
        devDependencies: {
          mocha: 'latest'
        }
      }
      packageJson.scripts[answer.unitTestScriptKey] = mochaTestScript
      packageJsonDirty = true
    }
    else {
      packageJson = JSON.parse(fs.readFileSync(packageJsonPath))
      packageJson.devDependencies = packageJson.devDependencies || {}
      if (!packageJson.devDependencies.mocha) {
        packageJson.devDependencies.mocha = 'latest'
      }

      if (!packageJson.scripts) {
        packageJson.scripts = {}
        packageJson.scripts[answer.unitTestScriptKey] = mochaTestScript
      }
      else {
        // The given unit test script already exists, we need to ask for
        // some unique ones. 
        while(packageJson.scripts[answer.unitTestScriptKey]) {
          answer = await inquirer.prompt({
            type: 'input', 
            name: 'unitTestScriptKey',
            message: `${answer.unitTestScriptKey} already exists. Try a different one?`,
            default: 'test:unit'
          })
        }
        packageJson.scripts[answer.unitTestScriptKey] = mochaTestScript
      }

      packageJsonDirty = true
    }

    if (packageJsonDirty || true) {
      fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2))

      // TODO: maybe run npm install in the final step with prompt?
      // return new Promise((resolve, reject) => {
      //   exec(`cd ${AsyncTaskRunner._getTargetPath('./')} && npm install`)
      //     .on('close', (code) => {
      //       code === 0 ? resolve() : reject()
      //     })
      // })
    }
  }

  /**
   * Create the functional test
   */
  async createFunctionalTests () {

  }

  async addFunctionalTestScripts () {

  }

  /**
   * Clean the directories/files created
   */
  async clean () {
    if (!this.log.autoGenerated) {
      // Nothing to clean
      return this
    }

    this.log.autoGenerated.forEach(autoGenPath => shell.rm('-rf', autoGenPath))
    this.log.autoGenerated = []

    return this
  }

  /**
   * Final tasks
   */
  async final () {
    // Create task log
    // Write auto generated logs
    fs.writeFileSync(AsyncTaskRunner.TASK_LOG_PATH, JSON.stringify(this.log))
  }
}

module.exports = AsyncTaskRunner